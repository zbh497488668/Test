Java虚拟机 源（深入理解Java虚拟机-JVM高级特性与最佳实践.pdf
）
 
程序计数器：在执行一个java方法的时候。计数器记录的是正在执行的虚拟机字节码指令的地址，如果是本地原生方法，，该计数器为空，这是唯一一个java虚拟机中没有规定任何outOfMemoryError 情况的区域
虚拟机栈：即描述java方法执行的内存模型：每个方法被执行都会同时创建栈帧，用于存储局部变量表，操作栈，动态链接，方法出口等，执行过程就是栈帧 入栈、出栈的过程了
我们平时俗称的栈。就是指虚拟机栈或者是虚拟机栈里面的局部变量表部分
栈帧：方法运行期的基础数据结构
局部变量表：存放各种数据类型、对象引用（即指向地址）、字节码指令地址。
一般的数据类型只占用一个局部变量空间，但64位长度的 long 和double 就会占用2个。
局部变量表所需的内存空间。。在编译时期就会确定下来。运行期间是不会改变大小的！

在该区域（虚拟机栈） 规定了2中异常状态 ，StackOverflowError（当线程请求的栈深度大于虚拟机所允许的深度）、outOfMemoryError（动态扩展的时候。无法申请到足够内存）
本地方法栈：与虚拟机栈相似，虚拟机栈是为虚拟机执行java方法服务，二本地方法栈是为虚拟机使用到的Native方法服务（我就理解为本地原生方法），有的虚拟机是直接将这2者合并。也会抛出StackOverflowError、outOfMemoryError

Java堆（Java Heap）
如图可知，堆，是被所有线程所共享的，在虚拟机启动时创建，此区域唯一目的就是存放对象实例 包括数组（随着优化技术不断发展，并不是所有实例都分配在堆上），此区域是内存中最大的一块。所以垃圾收集器管理中，这是主要区域！，从垃圾回收角度来看，堆会被划分为很多块，但和存放内容无关 ，目的只是为了更好的回收

方法区：与java堆一样。是被共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据.（我理解为，像全局变量、类信息这样的），这个区域的限制比较宽松，可以选择不实现垃圾收集，垃圾收集在这个区域也是比较少出现的，这区域的垃圾回收只是针对 常量池的回收，以及对类型的卸载。曾经出现若干个bug就是对该区域的回收未完全。造成内存泄露。 当方法区无法满足内存分配需求也是会抛出outOfMemoryError
运行时常量池：方法区的一部分，用于存放各种字面量和符号引用，来源于Class文件的常量池，在类加载后存放于此。具有动态性，就算是运行过程中。也可以将新的常量放入池中，当常量池无法申请到内存也是会抛出outOfMemoryError
直接内存：也会导致抛出outOfMemoryError，该区域不是运行时数据区的一部分，也不是java虚拟机规范中定义的内存区域，但是被频繁使用。
例如 jdk1.4 加入的nio类 ，引入了一种基于通道（channel）与缓冲区（buffer）的I/O
方式，使用Native函数库直接分配堆外内存，然后通过Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在java堆和native 堆来回赋值数据（我的理解就是直接将流读到该内存，避免了复制）。直接内存不受java堆大小限制，但是各内存区域总和+直接内存大于了。服务器管理员配置的大小，就会报outOfMemoryError

创建对象过程。在虚拟机里的表现

1.Object obj=new Object（）；
2.Object obj 作为引用类型数据会存入java 栈的本地变量表中
3.new Object（）实例会存入java 堆
4.在java堆的方法区内，存储 对象类型、父类、实现的接口、方法 等地址信息

至于对象访问方式会不同，主流的是：使用句柄、直接指针
使用句柄：java堆会划分出一块内存作为内存池，2里面的引用数据地址存的是句柄池的地址，该池里面存放了对象实例数据地址、对象类型数据地址 （优点比较稳定，就算因为垃圾收集时对象被移动等行为。只需改变句柄池里面的内容而已。）
直接指针：2里面的引用数据地址存的是对象实例数据的地址，如何存放对象类型数据地址就可能是自定义了 （优点比较快速，不用定位2 次）

模拟内存error
http://essen.iteye.com/blog/1825314 安装用Eclipse Memory Analyzer查找内存泄露（帮你查出问题所在）
StackOverflowError： 在单线程下内存无法分配时一般会抛出该异常
outOfMemoryError：可以在多进程的时候模拟出来。但跟栈大小没有关系，有时候栈内存分配的越大。反而更容易出现内存错误。因为。总的虚拟机可分配的内存是固定的。。一个个进程的内存分配大了。。那新建的进程。。没内存可分配了


垃圾回收机制：
在有些语言中。判断对象是否是死的。是否需要回收，像ios就是使用引用计数器。对象引用计数是0的时候。那就是可以回收。
但这个方法在java中相互引用的时候，貌似不好处理。所以java使用的是根搜索算法，一旦一个对象。，没办法连到根。那就断了就该回收了
2种方法的共同点就是。都跟引用有关
Java中。引用分为 强引用（只要改引用还在就不会被回收），软引用（非必须的，在内存快要溢出，，才准备回收），弱引用（只能生存到下一次垃圾回收前），虚引用（大概只是为了知道被回收的时候，接收通知）
垃圾回收，在堆中，回收效率是很高的。但是在方法区中却不高，方法区的东西要被回收。判断条件更苛刻，该区域里的主要是。废弃的常量和无用的类
必须满足3个条件
1.	该类的所有实例都已经被回收，也就是java堆中不存在该类的任何实例
2.	加载该类的ClassLoader已经被回收
3.	该类的对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
满足条件后。还要看你是否设置了要回收，因为这不是必然的

垃圾收集算法：
1．	标记-清除算法  找到根据判断需要清除而标记的对象。再清除掉。一 是效率不高，二是清除掉之后，会产生大量不连续的空间。会导致。运行过程中需要非配较大的内存时。不得不提前触发一次。垃圾收集动作
2．	复制算法：简单的就是将内存按容量大小分为大小相等的两块，每次只使用其中一块，当这块用完了。就将存活的对象复制到另外一块上面。然后把这块一次性清理，此方法简单高效。也就解决了碎片的问题，缺点是。能使用的内存是原来的一半。IBM提出的有种做法就是。。按8：1：1的比例来，分割为3块。90%（8+1）可以用于分配。当回收的时候。将90% 内存上面。还存活的对象放入另一块没使用的10%里面，如果对象超过这个10% 就需要依赖其他内存（老年代），进行担保分配，在对象存活率较高的时候。就要执行较多的复制操作，效率将会变低。
3．	标记-整理算法  找到根据判断需要清除而标记的对象，然后让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
4．	分代收集算法 当前的商业虚拟机都采用这种，根据对象存活周期不同将内存划分为几块，一般是把java堆分为新生代和老年代，新生代，一般都会大批死去少量存活。采用复制算法，只需要付出少量存活对象的复制成本就可以完成 。老年代确实存活率较高，使用其他2种方法

垃圾收集器
1.	Serial ：单线程，运行高效。但是在运行时。会停止用户的所有线程，   
2.	ParNew：Serial的多线程版本 
3.	CMS：并发（用户线程和垃圾收集同时）收集器使用“标记清除”。搭配前2者之一就可以实现，和用户线程同时工作。所以是很适合，b/s这样的模式。它整个过程分为四部，初始标记、并发标记、重新标记、并发清除。初始标记就是标记下gc roots能直接关联到的对象，速度很快。重新标记则是在并发标记时，由于用户的运作导致标记产生变动的。
CMS对CPU资源是很敏感的，并发阶段，虽然不会导致用户线程停顿，但是会占用线程（CPU资源）
4.	Parallel Scavenge 新生代收集器，使用复制算法的收集器，又是并行（收集多线程同时）的多线程收集器，专注于精确控制吞吐量，即一次收集的多少。一次收集的少了，那么用户等待时间就短了，但是收集的频率就变高了。所以。吞吐量大。用户等待时间就会变长 （吞吐量优先）
5.	Serial Old 收集器Serial 收集器的老年代版本 ，采用标记-整理算法 2大用途：1和Parallel Scavenge搭配使用。2作为CMS收集器的后备预案，并发失败的时候使用
6.	Parallel Old收集器 是Parallel Scavenge收集器的老年代版本 使用多线程和“标记-整理”算法（吞吐量优先）
7.	G1 收集器 是当前技术发展的最前沿成果了，一、基于“标记-整理”，没有了空间碎片的烦恼 二、精确的控制停顿，让使用者设置，在时间段内收集时间不得超过多少
可以实现基本不牺牲吞吐量的前提下完成低停顿的内存回收，因为他将java堆分为大小固定的多个区域，然后跟踪这些区域里面垃圾堆积程度，在后台维护一个优先列表。每次根据允许的收集时间，优先回收垃圾最多的区域。保证了在有限时间内，可以获得最高的收集效率
对象的内存分配
1.	优先存入eden空间。复制算法中，新生代中由一个eden 和2个survivor 组成
2.	大对象（很长的字符串 及数组）就可以设置 虚拟机参数（-XX：PretenureSizeThreshold 单位是B 该参数只对Serial 和ParNew这两款收集器有效）。直接存入老年代~  这么做，是因为大对象会提前出发垃圾收集（在实际上还有很大空间）。
3.	长期存活的对象将进入老年代。如何判断为老年代？实际上。虚拟机会给每个对象定义一个表示对象年龄的计数器，经历过一次MinorGc后仍然存活。并且能被Survivor容纳。将被移动到Survivor空间中，并将年龄设为1，如此每经历一次，年龄就+1，一直到15岁的时候。。。就会晋升到老年代中 这个15是默认（你也可以通过-xx：MaxTenuringThreshold 来设置）
4.	动态对象年龄判定 如果Survivor空间中，相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。无需等到MaxTenuringThreshold中要求的年龄
5.	空间分配担保 虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则改为直接进行一次Full GC 。如果小于则查看HandlePromotionFailure设置，是否允许担保失败。如果允许就只会进行Minor GC；如果不允许就改为进行一次Full GC
虚拟机性能监控与故障处理工具
1.	jps：虚拟机进程状况工具 列出正在运行的虚拟机进程
2.	jstat：虚拟机统计信息监视工具 用于监视虚拟机各种运行状况，运行期定位虚拟机性能问题的首选工具
3.	jinfo：java配置信息工具 实时查看和调整虚拟机各项参数
4.	jmap：java内存映像工具 用于生成堆转储快照 还可以查询finalize执行队列。Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等
5.	jhat：虚拟机堆转储快照分析工具 该命令和jmap搭配使用，来分析jmap生成的堆转储快照
6.	jstack：java堆栈跟踪工具 用于生成虚拟机当前时刻的线程快照
JDK的可视化工具
1.jConsole：java监视与管理控制台
